const fs = require('fs');
const process = require('process');
const glob = require('glob');
const path = require('path');
const yaml = require('js-yaml');
const parseArgs = require('minimist');
const {loadSchema, compileJSONSchemaToTs} = require('./compile_common');

const capitalize = s =>
  typeof s === 'string' && s.length >= 1
    ? s.charAt(0).toUpperCase() + s.slice(1)
    : '';
const uncapitalize = s =>
  typeof s === 'string' && s.length >= 1
    ? s.charAt(0).toLowerCase() + s.slice(1)
    : '';

const extractJsonSchemaFromApis = ({schemas}) =>
  schemas.reduce((all, {schema}) => {
    if (schema.swagger === '2.0') {
      return [
        ...all,
        ...openApiToTsV2Paths(schema).reduce(
          (all_paths, {path, method}) => [
            ...all_paths,
            ...extractJsonSchemaFromApiV2PathType(schema, path, method),
          ],
          [],
        ),
      ];
    } else {
      throw new Error('Unrecognized API schema version');
    }
  }, []);

const extractJsonSchemaFromApiV2PathType = (schema, path, method) => {
  const apiTitle = openApiToTsV2Title(schema);
  const pathTitle = openApiToTsV2PathTitle(schema, path, method);
  const types = [];
  if (schema.paths[path][method].parameters !== undefined) {
    const parameterTypes = {};
    const required = [];
    for (const parameter of schema.paths[path][method].parameters) {
      if (parameter.schema !== undefined) {
        parameterTypes[parameter.name] = {
          description: parameter.description,
          ...parameter.schema,
        };
        if (parameter.required) required.push(parameter.name);
      }
    }
    types.push({
      schema: {
        $schema: 'http://json-schema.org/draft-07/schema',
        title: `${apiTitle}${pathTitle}Request`,
        type: 'object',
        properties: parameterTypes,
        required,
      },
    });
  } else {
    types.push({
      schema: {
        $schema: 'http://json-schema.org/draft-07/schema',
        title: `${apiTitle}${pathTitle}Request`,
        type: 'null',
      },
    });
  }
  if (schema.paths[path][method].responses !== undefined) {
    const responseTypes = [];
    for (const responseCode in schema.paths[path][method].responses) {
      if (
        schema.paths[path][method].responses[responseCode].schema !== undefined
      ) {
        responseTypes.push(schema.paths[path][method].responses[responseCode]);
      }
    }
    if (responseTypes.length > 1) {
      types.push({
        schema: {
          $schema: 'http://json-schema.org/draft-07/schema',
          title: `${apiTitle}${pathTitle}Response`,
          oneOf: responseTypes.map(({schema, description}) => ({
            description,
            ...schema,
          })),
        },
      });
    } else if (responseTypes.length === 1) {
      types.push({
        schema: {
          $schema: 'http://json-schema.org/draft-07/schema',
          title: `${apiTitle}${pathTitle}Response`,
          description: responseTypes[0].description,
          ...responseTypes[0].schema,
        },
      });
    } else {
      types.push({
        schema: {
          $schema: 'http://json-schema.org/draft-07/schema',
          title: `${apiTitle}${pathTitle}Response`,
          type: 'null',
        },
      });
    }
  } else {
    types.push({
      schema: {
        $schema: 'http://json-schema.org/draft-07/schema',
        title: `${apiTitle}${pathTitle}Response`,
        type: 'null',
      },
    });
  }
  return types;
};

const apisToTs = ({schemas, compiled}) => `
/* tslint:disable */
/**
 * This file was automatically generated by bin/compile_apis.js.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source API Schema file,
 * and run bin/compile_apis.js to regenerate this file.
 */

import fetch from 'isomorphic-unfetch'

${compiled}

${schemas.map(openApiToTs).join('\n')}
`;

const openApiToTs = ({schema}) => {
  if (schema.swagger === '2.0') {
    return openApiToTsV2(schema);
  } else {
    throw new Error('Unrecognized API schema version');
  }
};

const openApiToTsV2Title = schema =>
  schema.info.title.replaceAll(/([^\w]|\s)+/g, '');

const openApiToTsV2PathTitle = (schema, path, method) => {
  if (schema.paths[path][method].operationId !== undefined) {
    return capitalize(
      schema.paths[path][method].operationId.replaceAll(/([^\w]|\s)+/g, ''),
    );
  } else {
    return capitalize(
      `${path
        .split('/')
        .map(capitalize)
        .join('')}${capitalize(method)}`.replaceAll(/([^\w]|\s)+/g, ''),
    );
  }
};

const openApiToTsV2Paths = schema =>
  Object.keys(schema.paths).reduce(
    (paths, path) => [
      ...paths,
      ...Object.keys(schema.paths[path]).map(method => ({path, method})),
    ],
    [],
  );

const openApiToTsV2 = schema => `
/**
 * ${yaml.dump(schema.info).replaceAll(/\n/g, '\n * ')}
 */
export class ${openApiToTsV2Title(schema)} {
  baseUrl: string

  constructor(baseUrl: string) {
    this.baseUrl = baseUrl
  }
${openApiToTsV2Paths(schema)
  .map(({path, method}) => openApiToTsV2PathResolve(schema, path, method))
  .join('\n')}
}
`;

const openApiToTsV2PathResolve = (schema, path, method) => {
  const apiTitle = openApiToTsV2Title(schema);
  const pathTitle = openApiToTsV2PathTitle(schema, path, method);
  return `
${
  schema.paths[path][method].description !== undefined
    ? `
  /**
   * ${schema.paths[path][method].description}
   */
`
    : ''
}
  async ${uncapitalize(
    pathTitle,
  )}(request: ${apiTitle}${pathTitle}Request): Promise<${apiTitle}${pathTitle}Response> {
    return ${apiTitle}${pathTitle}ResponseC.from(
      await fetch(this.baseUrl + ${JSON.stringify(path)}, {
        method: ${JSON.stringify(method)},
        body: JSON.stringify(request),
      })
    )
  }
`;
};

main(
  parseArgs(process.argv.slice(2), {
    alias: {
      help: ['h'],
      input: ['i'],
      output: ['o'],
    },
  }),
);

function main(argv) {
  if (argv.help === true) {
    console.log('usage: -i <input-glob> -o <output_file.ts>');
  } else if (argv.input !== undefined) {
    let input_root;
    let inputs;
    const pivot = argv.input.indexOf('*');
    if (pivot !== -1) {
      // some kind of glob
      input_root = argv.input.substr(0, pivot);
      inputs = glob.sync(argv.input);
    } else {
      // file
      input_root = path.dirname(argv.input);
      inputs = [argv.input];
    }
    const schemas = inputs.map(file => ({
      inputFile: path.relative(input_root, file),
      outputFile: path.relative(path.dirname(argv.output), file),
      schema: loadSchema(file),
    }));
    compileJSONSchemaToTs({
      schemas: extractJsonSchemaFromApis({schemas}),
      input_root,
    })
      .then(compiled => apisToTs({schemas, compiled}))
      .then(ts => fs.writeFileSync(argv.output, ts));
  }
}
